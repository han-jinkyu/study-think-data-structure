# 17. 정렬

정렬 알고리즘을 배워야 하는 이유는 다음과 같다.

1. 알아두어야 할 `특수 알고리즘`이 있기 때문이다.
    - `기수 정렬(radius sort)`
    - `제한된 힙 정렬(bounded heap sort)`
    
2. `병합 정렬(merge sort)`는 교육적으로 훌륭한 예이며, 알고리즘 설계에서 가장 중요하고 유용한 전략인 `분할 정복법(divide-conquer-glue)`을 보여주기 때문이다. 또한 알고리즘 성능을 분석할 때 보지 못한 `선형 로그(linearithmic)`라는 증가 차수를 배울 수 있다.

3. 기술 면접관이 이에 관해 질문하기 때문이다.


## 삽입 정렬

> 삽입 정렬(揷入整列, insertion sort)은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다. [위키 참조](https://ko.wikipedia.org/wiki/삽입_정렬)

```java
public void insertionSort(List<T> list, Comparator<T> comparator) {
    for (int i=1; i < list.size(); i++) {
        T elt_i = list.get(i);
        int j = i;
        while (j > 0) {
            T elt_j = list.get(j-1);
            if (comparator.compare(elt_i, elt_j) >= 0) {
                break;
            }
            list.set(j, elt_j);
            j--;
        }
        list.set(j, elt_i);
    }
}
```

- 2개의 중첩된 반복문이 있으므로 실행시간은 2차로 추측할 수 있다. 하지만 각 반복문의 실행 횟수가 배열의 크기인 n에 비례하는지 살펴봐야 한다.
    - 외부 반복문은 list.size()까지 반복한다. 따라서 리스트 크기인 n에 선형이다.
    - 내부 반복문은 i에서 0까지 반복하므로 역시 n에 선형적이다.
    
- 최악일 때는 2차지만 다음과 같은 특징이 있다.
    1. 요소가 이미 정렬되어 있거나 거의 정렬되어 있다면 선형이다. 특히 각 요소가 있어야 하는 자리 기준 k 이하의 위치에 있다면 내부 반복문은 k번 이하로 동작하게 되므로 전체 실행시간은 O(kn)이다.
    2. 구현이 단순하므로 오버헤드가 작다. 즉, 실행시간은 최대 an^2이지만 최대 차수의 계수인 a는 아마도 작을 것이다.


## 실습

- ListSorter.java
- ListSorterTest.java

> 합병 정렬 또는 병합 정렬(merge sort)은 O(n log n) 비교 기반 정렬 알고리즘이다. 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나이다. [위키 참조](https://ko.wikipedia.org/wiki/합병_정렬)

```java
public List<T> mergeSort(List<T> list, Comparator<T> comparator) {
    if (list.size() <= 1) {
        return list;
    }

    List<T> list1 = new LinkedList<>(list.subList(0, list.size() / 2));
    List<T> list2 = new LinkedList<>(list.subList(list.size() / 2, list.size()));

    List<T> sorted1 = mergeSort(list1, comparator);
    List<T> sorted2 = mergeSort(list2, comparator);

    return merge(sorted1, sorted2, comparator);
}
```


## 병합 정렬 분석

알고리즘의 단계는 다음과 같다.

1. 두 개의 새로운 배열을 만들고 요소의 반쪽씩 각각 복사한다. (선형)
2. 두 개의 반쪽들을 정렬한다.
3. 반쪽들을 병합한다. (선형)

그럼 두 번째 단계의 복잡도를 계산하여야 한다.

- 최상위 수준에서는 n개의 요소를 가지고 있는 1개의 리스트
- 최하위 수준에서는 1개의 요소를 가지고 있는 n개의 리스트


- 모든 수준에서는 총 n개의 요소가 존재한다.
- 내려가며 배열을 반으로 나누는 데 모든 수준에서 n에 비례하는 시간이 걸린다. 
- 돌아올 때는 총 n개의 요소를 병합해야 한다.

따라서 수준의 개수가 h라고 가정하면 총 O(hn)이 소요된다. 따라서 얼마나 많은 수준이 있는지 파악할 필요가 있다.

1. 1(최하위층)로 가기까지 n을 몇 번이나 반으로 나누어야 되는가?
2. 1에서 n으로 돌아가기 위해 2배를 몇 번이나 해야 하는가?
    - 2^h = n => h = log n
    
전체 시간은 `O(n * log n)`이 된다. 이는 요소들을 서로 비교하여 작동하는 정렬 알고리즘의 이론적 하한선으로 알려져 있다. 즉, 비교 정렬(comparison sort) 중에선 이보다 좋은 증가 차수가 없다는 뜻이다.


## 기수 정렬

`기수 정렬(radix sort)`은 `비교하지 않는(non-comparison) 정렬 알고리즘`으로 요소의 크기가 32bit 정수 또는 20 캐릭터 문자열과 같이 제한된 경우에 동작한다.

각 카드에 3글자 단어가 있는 인덱스 카드가 있다고 가정하면 정렬하는 법은 다음과 같다.

1. 첫 번째 글자를 기준으로 버킷을 나눈다. a로 시작하는 단어는 같은 버킷에 있고, 그 다음은 b로 시작한다.
2. 다시 두 번째 글자를 기준으로 버킷을 나눈다.
3. 다시 세 번째 글자를 기준으로 버킷을 나눈다.

각 단계에서 반복문을 실행하고 버킷에 추가하는 작업은 `선형`이다. 그리고 단계의 수는 `단어의 길이(w)`에 의존하게 된다. 따라서 증가 차수는 `O(wn)`이다.


## 힙 정렬

힙 정렬은 매우 큰 데이터셋에서 '상위 10'개 또는 '상위 k'개를 보고하는데 유용하다. (k < n)

힙 정렬을 이해하려면 이진 탐색 트리(BST)와 유사한 힙(heap)을 이해해야 한다. 둘의 다른 점은 다음과 같다.

- BST에서 모든 노드 x는 `BST 속성`을 갖는다. 즉, x의 왼쪽 하위 트리에 있는 모든 노드는 x보다 작고 오른쪽 하위 트리는 x보다 크다.
- 힙에서 모든 노드 x는 `힙 속성`을 갖는다. x의 양측 하위 트리의 노드는 모두 x보다 크다.
- 힙은 균형 BST와 같다. 요소를 추가하거나 제거하면 힙은 트리의 균형을 맞추는 작업을 추가로 한다. 결과적으로 요소의 배열을 사용하여 힙을 효율적으로 구현할 수 있다.


- 힙에 있는 가장 작은 요소는 항상 상수 시간으로 찾을 수 있다.
- 힙에서 요소를 추가하거나 제거하는 시간은 트리의 높이인 h에 비례한다.
- 힙은 항상 균형 있기 때문에 h(높이)는 log n에 비례한다.

자바의 `PriorityQueue` 클래스는 힙으로 구현되어 있으며 Queue 인터페이스에 정의된 offer와 poll 메서드를 제공한다.

- offer: 큐에 요소를 추가하며 모든 노드가 '힙 속성'을 갖도록 갱신한다. 실행시간은 log n이다. 
- poll: 루트로부터 큐에서 가장 작은 요소를 제거하고 힙을 갱신한다. 실행시간은 log n이다.

큐에 n개의 요소를 추가하거나 제거하는 것은 n * log n이 걸린다. 따라서 실행시간은 `n log n`이다.


## 제한된 힙 정렬

제한된 힙은 최대 k개의 요소만 담을 수 있 힙이다. n개의 요소가 있으면 다음과 같이 k개의 가장 큰 요소를 추적할 수 있다.

초기에 힙은 비어 있다. 각 요소인 x에 대해 다음을 수행한다.

- 분기 1: 힙이 가득 차지 않았다면 x를 힙에 추가한다.
- 분기 2: 힙이 가득 차면 x를 힙의 가장 작은 요소와 비교한다. x가 더 작으면 x는 상위 k개의 요소가 될 수 없으므로 버린다.
- 분기 3: 힙이 가득 차고 x가 힙의 가장 작은 요소보다 크면 힙에서 가장 작은 요소를 제거하고 x를 추가한다.
    
이 알고리즘의 성능을 분석하면 다음과 같다.

- 분기 1: 힙에 어떤 요소를 더하는 것은 `O(log k)`다.
- 분기 2: 힙에서 가장 작은 요소를 찾는 것은 `O(1)`이다.
- 분기 3: 가장 작은 요소를 제거하는 것은 `O(log k)`다. x를 추가하는 것도 `O(log k)`다.


## 공간 복잡도

- 병합 정렬의 단점 중 하나는 데이터의 복사본을 만든다는 것이다. 직접 구현한 코드에서 사용하는 총 공간은 O(n log n)이다. 좀 더 똑똑한 구현이라면 O(log n)으로 낮출 수 있다.
- 삽입 정렬은 그 자리에서 요소를 바로 정렬하기 때문에 데이터를 복사하지 않는다. 따라서 공간적으로 요소의 개수(n)에 의존하지 않는다.
- 직접 구현한 힙 정렬은 새로운 PriorityQueue를 생성하므로 공간은 O(n)이다. 하지만 리스트를 바로 그 자리에서 정렬하면 O(1) 공간에서 힙 정렬을 실행할 수 있다.
- 제한된 힙 정렬의 장점은 k에 비례하는 공간만 필요하다는 점이다.
- 대부분의 상황에서는 실행시간에 중점을 두어야 하나, 대규모 데이터셋을 다룰 때는 공간도 중요한 요소가 된다. 

---
[Home](../README.md)
