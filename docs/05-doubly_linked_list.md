# 5. 이중 연결 리스트

## 성능 프로파일 결과
이전 시간에 log-log 스케일로 문제 크기 대비 실행시간의 그래프를 그리고 결과 곡선의 기울기를 추정하였다

### ArrayList

#### AddBeginning
- 앞에 요소를 추가하는 연산은 선형
    - 다른 요소를 뒤로 시프트하기 때문
- 따라서 n번 추가 연산은 2차

#### AddEnd
- 끝에 요소를 추가하는 add 메서드는 n번 추가 연산시 전체 시간이 n에 비례 (기울기 1)
- 따라서 n번 추가 연산은 선형, O(n)
- 개별 add 메서드의 평균 시간은 상수 시간 또는 O(1)



### LinkedList

#### AddBeginning
- 앞에 요소를 n번 추가하는 연산은 선형
    - 시프트할 필요가 없기 때문
- 따라서 각 add 메서드는 상수 시간 

#### AddEnd
- 뒤에 요소를 추가하는 것은 끝까지 순회하여야 함
    - 즉 선형
- 따라서 n번 추가하는 연산의 전체 시간은 2차여야 함
- 그렇지만 그래프의 기울기를 1.19며 상수 시간임을 시사함
    - 왜?

## 이중 연결 리스트
MyLinkedList는 `단일 연결 리스트`였으나 LinkedList는 `이중 연결 리스트`다. 이는 다음을 뜻한다.

1. 각 노드는 이전 노드와 다음 노드를 포함한다
1. LinkedList 객체는 첫 번째 요소와 마지막 요소에 대한 참조를 가진다

즉 LinkedList는 리스트의 어느 한 끝에서 시작하여 어느 방향으로든 순회할 수 있다.
결과적으로 상수 시간으로 시작과 끝에 요소를 추가하고 삭제할 수 있다.

| 구분                | ArrayList | MyLinkedList | LinkedList |
|:-------------------|:---------:|:------------:|:----------:|
|add(끝)              | 1         | n            | 1         |
|add(시작)            | n         | 1            | 1          |
|add(일반적)           | n         | n            | n         |
|get/set             | 1         | n            | n          |
|indexOf/lastIndexOf | n         | n            | n          | 
|isEmpty/size        | 1         | 1            | 1          |
|remove(끝)           | 1         | n            | 1         |
|remove(시작)         | n         | 1            | 1          |
|remove(일반적)        | n         | n           | n          |

## 자료구조 선택하기

- 이중 연결 리스트는 ArrayList 클래스보다 시작에 요소를 추가/삭제하기 좋다
- 끝에 요소를 추가하는 것은 둘 다 동일
- ArrayList 클래스의 유일한 이점은 get/set 메서드
- 하지만 이런 추천은 큰 문제의 증가 차수에 기반을 두고 있다. 이 외 고려해야 할 요소는 다음과 같다.
    - 응용 프로그램이 다른 일을 하느라 시간을 소모하면 List 선택은 의미 없음
    - 작은 문제에 대해서는 그다지 기대하는 성능을 얻을 수 없다. 차이가 미미하기 때문.
    - 공간에 대해서도 잊으면 안 된다. 
        - ArrayList는 나란히 저장되어 공간 낭비가 없고 종종 속도가 빠름.
        - LinkedList는 노드마다 다른 노드를 참조하므로 공간을 더 차지하고 흩어져 있어서 하드웨어 효율이 떨어질 수 있다.
    
---
[Home](../README.md)
